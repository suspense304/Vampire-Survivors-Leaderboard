@page "/"

@using Models
@using Microsoft.EntityFrameworkCore;
@using System.Security.Claims
@using System.Diagnostics
@using Classes

@inject vswebsiteContext _context

<div style="width: 100%; text-align: center;"><h2>Top Players</h2></div>
<div class="dashboardItem">
    <div class="profileContent" style="box-shadow: 0px 2px 3px 1px rgba(0,0,0,0.59);">
        <MudTable Items="@topPlayers" Dense="true" Hover="true" FixedHeader="true">
            <HeaderContent>
                <MudTh>Place</MudTh>
                <MudTh>User</MudTh>
                <MudTh>Points</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="User">@(topPlayers.IndexOf(@context) + 1)</MudTd>
                <MudTd DataLabel="User"><a href=@("/Profile?id=" + @context.User.Id)>@context.User.DisplayName</a></MudTd>
                <MudTd DataLabel="User">@context.Points</MudTd>
            </RowTemplate>
        </MudTable>
    </div>
</div>
<br />
<br />
<div style="width: 100%; text-align: center;"><h2>Newest Submissions</h2></div>
<div class="dashboardItem">
    <div class="profileContent" style="box-shadow: 0px 2px 3px 1px rgba(0,0,0,0.59);">
        <MudTable Items="@entries" Dense="true" Hover="true" FixedHeader="true">
            <HeaderContent>
                <MudTh>User</MudTh>
                <MudTh>Character</MudTh>
                <MudTh>Stage</MudTh>
                <MudTh>Kills</MudTh>
                <MudTh>Level</MudTh>
                <MudTh>Gold</MudTh>
                <MudTh>Survived Time</MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="User"><a href=@("/Profile?id=" + @context.User.Id)>@context.User.DisplayName</a></MudTd>
                <MudTd DataLabel="Character">@context.Character.Name</MudTd>
                <MudTd DataLabel="Stage">@context.Stage.Name</MudTd>
                <MudTd DataLabel="Kills">@context.Kills</MudTd>
                <MudTd DataLabel="Level">@context.Level</MudTd>
                <MudTd DataLabel="Gold">@context.Gold</MudTd>
                <MudTd DataLabel="Survived Time">@context.SurvivedTime</MudTd>
                <MudTd DataLabel=""><a href=@("/Entry?id=" + @context.Id)>View</a></MudTd>
            </RowTemplate>
        </MudTable>
    </div>
</div>



@code {

	static readonly List<int> pointsAwarded = new List<int> { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
	bool isAdmin;
	List<Entry> entries = new List<Entry>();
	List<CompositeStats> topPlayers = new List<CompositeStats>();

	[CascadingParameter]
	private Task<AuthenticationState> authenticationStateTask { get; set; }

	protected override async Task OnInitializedAsync()
	{
		var authState = await authenticationStateTask;
		var user = authState.User;
		var userId = user.FindFirstValue(ClaimTypes.NameIdentifier);
		User chkUser = _context.Users.Where(w => w.UserKey == userId).FirstOrDefault();
		if (chkUser != null) isAdmin = chkUser.Admin;

		int topN = 10;
		entries = await GetRecentSubmissions();
		topPlayers = CalculatePoints(topN);
	}

	private List<Entry> RemoveDupes(List<Entry> records)
	{
		Dictionary<User, int> nameCheck = new Dictionary<User, int>();
		List<Entry> newList = new List<Entry>();
		for (int i = 0; i < records.Count; i++)
		{
			if (!nameCheck.ContainsKey(records[i].User))
			{
				Entry newEntry = _context.Entries.Where(w => w.Id == records[i].Id).First();
				newList.Add(newEntry);
				nameCheck.Add(records[i].User, records[i].Id);
			}
		}
		return newList;
	}

	private async Task<List<Entry>> GetRecentSubmissions()
	{
		var profile = Stopwatch.StartNew();

		var entries = await _context.Entries
			.Include(i => i.User)
			.Include(i => i.Stage)
			.Include(i => i.Character)
			.Where(w => w.Approved == true && w.Deleted == false)
			.OrderByDescending(o => o.DateSubmitted)
			.Take(10)
			.ToListAsync();

		profile.Stop();
		Debug.WriteLine($"GetRecentSubmissions: {profile.Elapsed}");

		return entries;
	}

	// TODO: Cache (user, record) stats. Update stats for a user upon submission. Retrieve data from cache and fallback to database.
	// TODO: Balance fallback against individual vs. all?
	// TODO: Perhaps, upon app initialization it populates the cache. Trade startup time for better lifetime performance?
	private List<CompositeStats> CalculatePoints(int topN)
	{
		var profile = Stopwatch.StartNew();

		List<Entry> records = new List<Entry>();
		Dictionary<User, int> playerPoints = new Dictionary<User, int>();
		var stages = _context.Stages.ToList();
		int stageCount = stages.Count;

		for (int stageID = 1; stageID < stageCount + 1; stageID++)
		{
			var killRecords = GetRecords(stageID, entry => entry.Kills, topN);
			var goldRecords = GetRecords(stageID, entry => entry.Gold, topN);
			var levelRecords = GetRecords(stageID, entry => entry.Level, topN);
			var timeRecords = GetRecords(stageID, entry => entry.SurvivedTime, topN);

			//DebugDumpTopNRecords(stages[stageID-1], killRecords, "Kills", entry => entry.Kills);
			//DebugDumpTopNRecords(stages[stageID-1], goldRecords, "Gold", entry => entry.Gold);
			//DebugDumpTopNRecords(stages[stageID-1], levelRecords, "Level", entry => entry.Level);
			//DebugDumpTopNRecords(stages[stageID-1], timeRecords, "Time", entry => entry.SurvivedTime);

			AddTally(killRecords, topN, playerPoints);
			AddTally(goldRecords, topN, playerPoints);
			AddTally(levelRecords, topN, playerPoints);
			AddTally(timeRecords, topN, playerPoints);
		}

		var topPlayers = (from playerResult in playerPoints
			orderby playerResult.Value descending
			select new CompositeStats
			{
				User = playerResult.Key,
				Points = playerResult.Value
			})
			.Take(topN)
			.ToList();

		profile.Stop();
		Debug.WriteLine($"CalculatePoints: {profile.Elapsed}");

        return topPlayers;
    }

	List<Entry> GetRecords<T>(int stageId, Func<Entry, T> statSelector, int topN)
	{
		return _context.Entries.Include(i => i.User)
			.Where(w => w.StageId == stageId && w.Approved == true && w.Deleted == false)
			// TODO: Not sure how well this would scale if there were tons of users, but for now it has to be client-side
			// TODO: loading before performing grouping, etc.
			.AsEnumerable()
			.GroupBy(
				entry => entry.UserId,
				(userId, group) => group.OrderByDescending(statSelector).First()
			)
			.OrderByDescending(statSelector)
			// TODO: These following sorts are probably needed for accuracy and consistency, but they also add ~5 seconds, which
			// TODO: eats away the ~3 seconds of gain found through refactoring.
			// TODO: I've left them off simply because they were not present in the original. I don't want to make the call :).
			//.ThenByDescending(entry => entry.DateSubmitted)
			// TODO: Not sure how this behaves with unicode names and the like
			//.ThenBy(entry => entry.User.Name)
			.Take(topN)
			.ToList();
	}

	// Preconditions: entries != null, entry.Count > 0, topN > 0
	void AddTally(List<Entry> entries, int topN, Dictionary<User, int> playerPoints)
	{
		for(int idx = 0; idx < topN; idx++)
		{
			var user = entries[idx].User;
			if (user != null)
			{
				if (playerPoints.ContainsKey(user))
				{
					playerPoints[user] += pointsAwarded[idx];
				}
				else
				{
					playerPoints.Add(user, pointsAwarded[idx]);
				}

				//Debug.WriteLine(user.Name + " + " + pointsAwarded[idx].ToString());
			}
			else
			{
				Debug.WriteLine("How the fuck did this happen?");
			}
		}
	}

	void DebugDumpTopNRecords<T>(Stage stage, List<Entry> entries, string stat, Func<Entry, T> statSelector)
	{
		var offset = entries.Max(entry => entry.User.Name.Length);
		var formattedRecordEntry = "Record holder: {0,-" + offset + "}\t{1}: {2}";

		Debug.WriteLine($"========{stage.Name}========");
		foreach(var entry in entries)
		{
			Debug.WriteLine(formattedRecordEntry, entry.User.Name, stat, statSelector(entry));
		}
		Debug.WriteLine($"===================");
	}
}


