@page "/"

@using Models
@using Microsoft.EntityFrameworkCore;
@using System.Security.Claims
@using System.Diagnostics
@using Classes

@inject vswebsiteContext _context

<div style="width: 100%; text-align: center;"><h2>Top Players</h2></div>
<div class="dashboardItem">
    <div class="profileContent" style="box-shadow: 0px 2px 3px 1px rgba(0,0,0,0.59);">
        <MudTable Items="@topPlayers" Dense="true" Hover="true" FixedHeader="true">
            <HeaderContent>
                <MudTh>Place</MudTh>
                <MudTh>User</MudTh>
                <MudTh>Points</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="User">@(topPlayers.IndexOf(@context) + 1)</MudTd>
                <MudTd DataLabel="User"><a href=@("/Profile?id=" + @context.User.Id)>@context.User.DisplayName</a></MudTd>
                <MudTd DataLabel="User">@context.Points</MudTd>
            </RowTemplate>
        </MudTable>
    </div>
</div>
<br />
<br />
<div style="width: 100%; text-align: center;"><h2>Newest Submissions</h2></div>
<div class="dashboardItem">
    <div class="profileContent" style="box-shadow: 0px 2px 3px 1px rgba(0,0,0,0.59);">
        <MudTable Items="@entries" Dense="true" Hover="true" FixedHeader="true">
            <HeaderContent>
                <MudTh>User</MudTh>
                <MudTh>Character</MudTh>
                <MudTh>Stage</MudTh>
                <MudTh>Kills</MudTh>
                <MudTh>Level</MudTh>
                <MudTh>Gold</MudTh>
                <MudTh>Survived Time</MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="User"><a href=@("/Profile?id=" + @context.User.Id)>@context.User.DisplayName</a></MudTd>
                <MudTd DataLabel="Character">@context.Character.Name</MudTd>
                <MudTd DataLabel="Stage">@context.Stage.Name</MudTd>
                <MudTd DataLabel="Kills">@context.Kills</MudTd>
                <MudTd DataLabel="Level">@context.Level</MudTd>
                <MudTd DataLabel="Gold">@context.Gold</MudTd>
                <MudTd DataLabel="Survived Time">@context.SurvivedTime</MudTd>
                <MudTd DataLabel=""><a href=@("/Entry?id=" + @context.Id)>View</a></MudTd>
            </RowTemplate>
        </MudTable>
    </div>
</div>



@code {
	bool isAdmin;
	List<Entry> entries = new List<Entry>();
	List<CompositeStats> topPlayers = new List<CompositeStats>();

	[CascadingParameter]
	private Task<AuthenticationState> authenticationStateTask { get; set; }

	protected override async Task OnInitializedAsync()
	{

		var authState = await authenticationStateTask;
		var user = authState.User;
		var userId = user.FindFirstValue(ClaimTypes.NameIdentifier);
		User chkUser = _context.Users.Where(w => w.UserKey == userId).FirstOrDefault();
		if (chkUser != null) isAdmin = chkUser.Admin;

		entries = await _context.Entries
		.Include(i => i.User)
		.Include(i => i.Stage)
		.Include(i => i.Character)
		.Where(w => w.Approved == true && w.Deleted == false)
		.OrderByDescending(o => o.DateSubmitted)
		.Take(10)
		.ToListAsync();

		var profile = Stopwatch.StartNew();

		CalculatePoints(topPlayers);

		profile.Stop();
		Debug.WriteLine($"CalculatePoints: {profile.Elapsed}");

		topPlayers = topPlayers.Take(10).ToList();
	}

	private List<Entry> RemoveDupes(List<Entry> records)
	{
		Dictionary<User, int> nameCheck = new Dictionary<User, int>();
		List<Entry> newList = new List<Entry>();
		for (int i = 0; i < records.Count; i++)
		{
			if (!nameCheck.ContainsKey(records[i].User))
			{
				Entry newEntry = _context.Entries.Where(w => w.Id == records[i].Id).First();
				newList.Add(newEntry);
				nameCheck.Add(records[i].User, records[i].Id);
			}
		}
		return newList;
	}

	// TODO: Cache (user, record) stats. Update stats for a user upon submission. Retrieve data from cache and fallback to database.
	// TODO: Balance fallback against individual vs. all?
	// TODO: Perhaps, upon app initialization it populates the cache. Trade startup time for better lifetime performance?
	private List<CompositeStats> CalculatePoints(List<CompositeStats> lst)
	{
		List<int> pointsAwarded = new List<int> { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
        List<Entry> records = new List<Entry>();
        Dictionary<User, int> playerPoints = new Dictionary<User, int>();
        int StageCount = _context.Stages.ToList().Count;

        int lstCount;

        for (int x = 1; x < StageCount + 1; x++)
        {
            Stage stage = _context.Stages.Where(w => w.Id == x).FirstOrDefault();

            //Sort List By Kills
            Debug.WriteLine(stage.Name + " Kills Leaders");
            records = _context.Entries
            .Include(i => i.User)
            .Where(w => w.StageId == x && w.Approved == true && w.Deleted == false)
            .OrderByDescending(o => o.Kills)
            .ToList();

            var killsRecords = _context.Entries
                            .Include(i => i.User)
                            .Where(w => w.StageId == x && w.Approved == true && w.Deleted == false)
                            .OrderByDescending(o => o.Kills)
                            .ToList()
                            .GroupBy(g => (g.User))
                            .Select(s => s.First()).ToList();

			// TODO: 10 -> a variable for a user-controlled Top N records might be feasible with better performance.
			// TODO: Not quite sure how that would work for the point-based system, though.
			lstCount = Math.Min(killsRecords.Count, 10);

			// Preconditions: entries != null, entrie.Count > 0, topN > 0
			void AddTally(List<Entry> entries, int topN)
			{
				for(int idx = 0; idx < topN; idx++)
				{
					var user = entries[idx].User;
					if (user != null)
					{
						if (playerPoints.ContainsKey(user))
						{
							playerPoints[user] += pointsAwarded[idx];
						}
						else
						{
							playerPoints.Add(user, pointsAwarded[idx]);
						}

						//Debug.WriteLine(user.Name + " + " + pointsAwarded[idx].ToString());
					}
					else
					{
						Debug.WriteLine("How the fuck did this happen?");
					}
				}
			}

			if (killsRecords.Count > 0)
			{
				AddTally(killsRecords, lstCount);

				//Sort List By Gold
				Debug.WriteLine(stage.Name + " Gold Leaders");

				var goldRecords = _context.Entries
							.Include(i => i.User)
							.Where(w => w.StageId == x && w.Approved == true && w.Deleted == false)
							.OrderByDescending(o => o.Gold)
							.ToList()
							.GroupBy(g => (g.User))
							.Select(s => s.First()).ToList();


				lstCount = (goldRecords.Count < 10) ? goldRecords.Count : 10;
				AddTally(goldRecords, lstCount);

				//Sort List By Level
				Debug.WriteLine(stage.Name + " Level Leaders");
				var levelRecords = _context.Entries
							.Include(i => i.User)
							.Where(w => w.StageId == x && w.Approved == true && w.Deleted == false)
							.OrderByDescending(o => o.Level)
							.ToList()
							.GroupBy(g => (g.User))
							.Select(s => s.First()).ToList();


				lstCount = (levelRecords.Count < 10) ? levelRecords.Count : 10;
				AddTally(levelRecords, lstCount);

				//Sort List By Survived
				Debug.WriteLine(stage.Name + " Survived Leaders");
				var timeRecords = _context.Entries
							.Include(i => i.User)
							.Where(w => w.StageId == x && w.Approved == true && w.Deleted == false)
							.OrderByDescending(o => o.SurvivedTime)
							.ToList()
							.GroupBy(g => (g.User))
							.Select(s => s.First()).ToList();


				lstCount = (timeRecords.Count < 10) ? timeRecords.Count : 10;
				AddTally(timeRecords, lstCount);
			}
		}

        List<KeyValuePair<User, int>> PlayerList = playerPoints.ToList();
        PlayerList.Sort((firstPair, nextPair) => firstPair.Value.CompareTo(nextPair.Value));

        foreach (var player in PlayerList)
        {
            CompositeStats newPlayer = new CompositeStats
            {
                User = player.Key,
                Points = player.Value
            };
            lst.Add(newPlayer);
        }
        lst.Reverse();
        return lst;
    }

}


